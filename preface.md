# Un coup de levier: Préfaces

![Caffe Molinari](images/caffemolinari.jpg)

> "Le Café Allongé, également appelé Espresso Lungo, est une boisson à mi-chemin entre un Espresso et un Americano. Il existe deux manières de le préparer. La première, celle que je préfère, consiste à ajouter une petite quantité d'eau chaude à un double ou quadruple Espresso Ristretto. C'est comme ajouter une petite goutte d’eau au whisky, la petite dilution libère davantage de saveurs complexes dans la bouche.
>
> "La deuxième méthode consiste à extraire un double jet d’Espresso extra-long. Cela donne à peu près le même rapport extrait à eau que la méthode de dilution, mais libère également un mélange de saveurs différents en raison de la plus longue extraction. Certains se plaignent que le long est plus amer et nuit au meilleur caractère du café, d’autres estiment que cela libère encore plus de complexité.
>
> "L'important, c'est qu'aucune des méthodes de préparation ne doit utiliser autant d'eau pour un résultat final maladif, fantôme pâle de l'Espresso. La modération en toutes choses."

## Avant-Propos par Michael Fogus

En tant que bibliophile tout au long de ma vie et follower de longue date du travail en ligne de Reg, j'étais enthousiasmé lorsqu'il a commencé à écrire des livres. Cependant, je suis très conservateur à propos des livres -- disons simplement que s'il y avait un après-rasage parfumé à l'essence des "Librairies de Livres d'occasion", je serais le premier à en acheter. Donc, comme vous pouvez l’imaginer, j’étais «sceptique» face à la décision de publier JavaScript Allongé sous forme de livre électronique en cours, avec un modèle de paiement à la carte. Cependant, Reg m'a envoyé une copie de son livre et j'ai été humilié. Non seulement c'était un bon livre, mais c'était aussi un excellent moyen d'écrire et de distribuer des livres. Ayant moi-même écrit des livres, je connais la douleur de solliciter et de recevoir des feedbacks.

L'acte d'écrire est un processus itératif avec (très souvent) des boucles de révision limitées. Cependant, le processus de sollicitation de feedbacks, de collecte de réponses, d’envoi de copies, d’attendre que les gens le lisent réellement (s’ils le font), de recevoir des feedbacks, puis de donner un sens ultime à son utilisation prend parfois des semaines, voir des mois. À plus d'une occasion, je me suis retrouvé à essayer de réifier les feedbacks avec du contenu qui n'existe plus ou qui a été modifié de façon totalement indescriptible. Cependant, avec le modèle Leanpub, le processus de lecture-feedback-changement est extrêmement efficace, laissant dans son sillage un livre de qualité qui continue à s’améliorer alors que d’autres lisent et commentent également à l’infini.

Dans le cas de JavaScript Allongé, le modèle Leanpub est un exemple probant d’efficacité. Reg a conçu (et continue de le faire) non seulement un livre intéressant du point de vue d'un connaisseur, mais également une exploration divertissante de certains des aspects les plus intéressants de son art. Quel que soit votre niveau d'expert, JavaScript Allongé a quelque chose à vous apprendre ... sur le café. Je blague.

En tant que fervent défenseur de la programmation fonctionnelle, une grande partie de ce que Reg a écrit sonne vrai pour moi. Bien qu’il ne s’agisse pas exclusivement d’un livre sur la programmation fonctionnelle, JavaScript Allongé fournira une base solide pour les techniques fonctionnelles. Cependant, vous ne serez pas battu au sujet de la tête et du cou avec un dogme. Au lieu de cela, chaque section est motivée par un dialogue pertinent et renforcée par des exemples de sources convaincants. En tant qu’auteur de livres de programmation, j’admire ce que Reg a réussi à faire et j’envie le bon lecteur qui trouve JavaScript Allongé via un canal obscur dans la toile d'Internet et le lit pour la première fois.

Bonne dégustation.

-- Fogus, [fogus.me](http://www.fogus.me)

## Avant-Propos par Matthew Knox

Un style de langage différent nécessite un style de livre différent.

JavaScript détient une profondeur surprenante -- ses règles de portée ne sont ni strictement lexicales ni strictement dynamiques, et il prend en charge la programmation procédurale, orientée objet (dans plusieures saveurs ! ) et la programmation fonctionnelle.  De nombreux livres essaient de cacher la plupart de ces fonctionnalités, en vous proposant des recettes pour écrire du code JavaScript d'une manière qui se rapproche de la programmation centrée sur les classes dans d'autres langues. Pas JavaScript Allongé. Il commence par les principes fondamentaux des valeurs, des fonctions et des objets, puis vous guide à travers JavaScript avec des bits de code exploratoires illustrant la portée, les combinateurs, le contexte, les états, les prototypes et les constructeurs.

Comme JavaScript, ce livre vous donne un bon départ avant de vous montrer toute sa profondeur, et comme un Café Allongé, c'est fini trop tôt.  Bonne dégustation !

--Matthew Knox, [mattknox.com](http://mattknox.com)

## Pourquoi Javascript Allongé?

*JavaScript Allongé* résout deux problèmes importants pour le codeur JavaScript ambitieux. Premièrement, *JavaScript Allongé* vous donne les outils nécessaires pour traiter les bugs JavaScript, les problèmes rencontrés, les cas extrêmes et d'autres pièges potentiels.

Il existe de nombreuses indications pour écrire des scripts JavaScript. Si vous les suivez sans altération ni déviation, vous serez satisfait. Malheureusement, le logiciel est une chose complexe, pleine d’interactions et d’effets secondaires. Deux conseils parfaitement raisonnables pris séparément peuvent être contradictoires lorsqu'ils sont pris ensemble. Une approche peut sembler judicieuse au début d'un projet, mais doit être révisée lorsque de nouvelles exigences sont découvertes.

Lorsque vous "quittez le chemin" des directions, vous découvrez leurs limites. Afin de résoudre les problèmes qui se produisent sur les bords, afin d'adapter et de gérer les changements, de procéder à une refactorisation et à une réécriture, le cas échéant, vous devez comprendre en détail les principes sous-jacents du langage de programmation JavaScript.

Vous devez comprendre *pourquoi* les instructions fonctionnent pour pouvoir comprendre *comment* les modifier pour qu'elles fonctionnent correctement au-delà de leurs limites d'origine. C'est là que *JavaScript Allongé* entre en jeu.

*JavaScript Allongé* est un livre sur la programmation avec des fonctions, car [JavaScript] est un langage de programmation basé sur des fonctions souples et puissantes. *JavaScript Allongé* commence au début, avec des valeurs et des expressions, et se construit à partir de là pour discuter des types, de l'identité, des fonctions, des fermetures, des portées et de nombreux autres sujets pouvant aller jusqu'à l'utilisation de classes et d'instances. Dans chaque cas, *JavaScript Allongé* se charge d'expliquer exactement comment les choses fonctionnent afin que, lorsque vous rencontrez un problème, vous sachiez exactement ce qui se passe et comment le résoudre.

Deuxièmement, *JavaScript Allongé* fournit des recettes permettant d’utiliser des fonctions pour écrire un logiciel plus simple, plus propre et moins compliqué que les approches alternatives centrées sur l’objet ou le code. Les idiomes JavaScript tels que les combinateurs de fonctions et les décorateurs exploitent le pouvoir de JavaScript pour faciliter la lecture, la modification, le débogage et le refactorisation du code, *évitant* ainsi les problèmes avant qu'ils ne surviennent.

*JavaScript Allongé* vous apprend à gérer un code complexe et à simplifier le code sans le perdre. En conséquence, *JavaScript Allongé* est une lecture riche libérant de nombreuses subtilités de JavaScript, un peu comme le Café Allongé tant aimé par les amateurs de café.

[JavaScript]: https://developer.mozilla.org/en-US/docs/JavaScript

### Comment le livre est organisé

*JavaScript Allongé* introduit de nouveaux aspects du codage avec des fonctions dans chaque chapitre, expliquant exactement le fonctionnement de JavaScript. Les exemples de codes contenus dans chaque chapitre sont petits et mettent l’accent sur l’exposition plutôt que sur les modèles à utiliser au quotidien.

Chaque chapitre est suivi d’une série de recettes conçues pour montrer l’application pratique des idées des chapitres. Bien que le contenu de chaque chapitre repose naturellement sur ce qui a été discuté dans le chapitre précédent, les recettes peuvent s’appuyer sur n’importe quel aspect du langage de programmation JavaScript.

## Un Mot Personel au Sujet des Recettes

Comme indiqué précédemment, *JavaScript Allongé* alterne entre les chapitres décrivant la sémantique des fonctions de JavaScript et les chapitres contenant les recettes permettant d'écrire des programmes avec des fonctions. Vous pouvez lire le livre dans l'ordre ou lire les chapitres expliquant d'abord JavaScript et revenir aux recettes plus tard.

Les recettes partagent un thème commun : elles sont issues d'un style de programmation inspiré par la création de petites fonctions qui composent les unes avec les autres. En utilisant ces recettes, vous apprendrez quand il convient d'écrire :

    return mapWith(maybe(getWith('name')))(customerList);

Au lieu de :

    return customerList.map(function (customer) {
      if (customer) {
        return customer.name
      }
    });

Ainsi que comment cela fonctionne et comment le refactoriser quand vous avez besoin. Ce style de programmation n’est guère la chose la plus courante en JavaScript. L’on peut donc affirmer que des recettes plus "pratiques" ou "banales" seraient utiles. Si vous ne lisez jamais d'autres livres sur JavaScript, si vous évitez les blogues et les vidéos sur JavaScript, si vous n'assistez pas à des ateliers ou des discussions sur JavaScript, alors je conviens que ce n'est pas un Seul Livre pour les Dominer Tous.

Mais étant donné qu’il existe d’autres ressources et que les programmeurs sont des créatures curieuses qui ont une soif inépuisable de croissance personnelle, nous avons choisi de vous proposer des recettes que vous ne trouverez probablement pas ailleurs dans cette concentration. Les recettes renforcent les leçons du livre sur les fonctions en JavaScript.

Vous trouverez toutes les recettes collectées en ligne sur [http://allong.es](http://allong.es). Ils sont libres de partager sous la licence MIT.

[Reginald Braithwaite](http://braythwayt.com)  
reg@braythwayt.com  
@raganwald

## Légende

Un texte de type monospaced tel que `this` dans le texte représente du code en cours de discussion. Certains codes monospaces dans ses propres lignes représentent également le code en cours de discussion :

    this.async = do (async = undefined) ->

      async = (fn) ->
        (argv..., callback) ->
          callback(fn.apply(this, argv))

Parfois, il contiendra du code que vous pourrez saisir vous-même. Lorsque cela se produit, le résultat de la saisie de quelque chose sera souvent affiché avec `// =>`, comme ceci :

    2 + 2
      //=> 4

T> Un paragraphe marqué comme ceci est un "fait essentiel". Cela résume une idée sans rien ajouter de nouveau.

X> Un paragraphe marqué comme ceci est un exercice suggéré que vous devez effectuer vous-même.

A> Un paragraphe marqué comme ceci est un aparté. Il peut être ignoré en toute sécurité. Il contient whimsey et autres logorrhées doupleplusunserious qui ne seront *pas* testées.

## JavaScript Allongé, la "Six" Edition

Ceci est la version originale de JavaScript Allongé. Il a été écrit pour ECMAScript-5. Le thème général du livre et son approche de la programmation sont aussi valables qu’aujourd’hui quand ECMAScript-5 était la norme pour JavaScript, mais les détails de la meilleure façon de mettre en œuvre ces idées ont changé.

Par example, en ECMAScript-5, on écrit :

    function maybe (fn) {
      return function () {
        var i;

        if (arguments.length === 0) {
          return
        }
        else {
          for (i = 0; i < arguments.length; ++i) {
            if (arguments[i] == null) return
          }
          return fn.apply(this, arguments)
        }
      }
    }

Mais en ECMAScript-2015, on écrit :

    const maybe = (fn) =>
      function (...args) {
        if (args.length === 0) {
          return
        }
        else {
          for (let arg in args) {
            if (arg == null) return;
          }
          return fn.apply(this, args)
        }
      }

Parmi les autres modifications, citons l'introduction du mot-clé `class`, qui suscite un intérêt accru pour l'utilisation d'objets, de prototypes et de fonctions.

Pour cette raison, ce manuscrit original a été retiré et une édition sensiblement mise à jour, [JavaScript Allongé, l'édition "Six"] [j6] a été écrite. S'il vous plaît profiter de cette copie, mais assurez-vous de lire la dernière édition.

[j6]: https://leanpub.com/javascriptallongesix

# Prélude: Valeurs et Expressions

*Le matériel suivant est extrêmement basique, mais comme dans la plupart des histoires, la meilleure façon de commencer est de commencer au tout début.*

Imaginez que nous visitons notre café préféré. Ils nous feront à peu près n'importe quelle boisson de notre choix, d'un expresso ristretto intense à un cappuccino sec, en passant par des préparations à base de café au goût de café contenant divers sirops et laits concentrés. (Vous tolérez l’existence de boissons sucrées car elles offrent une marge bénéficiaire suffisante à l’établissement pour que vous puissiez rester toute la journée à procrastiner via la WiFi en commandant une boisson à 1,20 € toutes les quelques heures.)

Vous exprimez votre commande à un bout du comptoir, les gens derrière le comptoir réalisent la magie et vous livrent le café que vous appréciez à l'autre bout. C’est exactement comme cela que fonctionne l’environnement JavaScript aux fins de ce livre. Nous allons nous passer de serveurs Web, navigateurs et autres complexités et traiter ce modèle simple: vous donnez une [expression] à l'ordinateur, elle renvoie une [valeur], exactement comme vous exprimez vos souhaits à un bariste et recevez un café. en retour.

Pous allons utiliser NodeJS, tout simplement en l'installant et en ouvrant une fenêtre de commande, on saisie `node` puis on execute notre code.

[expression]: https://fr.wikipedia.org/wiki/Expression_(informatique)
[valeur]: https://fr.wikipedia.org/wiki/Valeur_(informatique)

## valeurs et expressions

Toutes les valeurs sont des expressions. Dites que vous commandez au bariste un café Cubano. Eh oui, vous remettez une tasse à café. Vous dites : "Je veux une de ces boissons." Le bariste n’est pas idiot, il vous rend la tasse tout de suite et vous obtenez exactement ce que vous voulez. Ainsi, un café cubano est une expression (vous pouvez l'utiliser pour passer une commande) et une valeur (vous la récupérez du bariste).

Essayons ceci avec quelque chose que peut facilement comprendre l'ordinateur :

    42

Est-ce que ceci est une expression ? Une valeur ? Aucune des deux ? Ou les deux ?

La réponse est que c’est à la fois une expression *et* une valeur. [^representation] Il est très facile de dire que c’est très simple : lorsque vous le saisissez en JavaScript, vous obtenez la même chose, tout comme notre café Cubano :

    42
      //=> 42

[^representation]: Techniquement, c'est une *représentation* d'une valeur utilisant la notation Base10, mais nous n'avons pas à nous en préoccuper dans ce livre. Vous et moi comprenons tous les deux que cela signifie "42", de même que l'ordinateur.

Toutes les valeurs sont des expressions. C'est facile ! Existe-t-il d'autres types d'expressions ? Biensûre ! Retournons au café. Au lieu de remettre le café fini, nous pouvons remettre les ingrédients. Remettons un peu de café moulu et de l’eau bouillante.

{pagebreak}

A> Les lecteurs astucieux se rendront compte que nous omettons quelque chose. Toutes nos félicitations ! Prenez une gorgée d'expresso. Nous y reviendrons dans un instant.

Maintenant, le bariste nous rend un expresso. Et si nous remettons l'expresso, nous récupérons celui-ci. L'eau bouillante et le café moulu sont donc une expression, mais ce n'est pas une valeur. [^homoiconicity] L'eau bouillante est une valeur. Le café moulu est une valeur. L'expresso est une valeur. L'eau bouillante plus le café moulu est une expression.

[^homoiconicity]: Dans certains langages, les expressions sont une sorte de valeur en elles-mêmes et peuvent être manipulées. Le grand-père de ces langues est Lisp. JavaScript n'est pas un tel langage, les expressions en elles-mêmes ne sont pas des valeurs.

Essayons aussi cela avec quelque chose d'autre que l'ordinateur comprend facilement:

    "JavaScript" + " " + "Allonge"
      //=> "JavaScript Allonge"

Nous voyons maintenant que les "chaînes" sont des valeurs et vous pouvez créer une expression à partir de chaînes et d'un opérateur `+`. Puisque les chaînes sont des valeurs, elles sont aussi des expressions en elles-mêmes. Mais les chaînes avec des opérateurs ne sont pas des valeurs, ce sont des expressions. Maintenant, nous savons ce qui manquait avec notre exemple "café moulu plus eau chaude". Le marc de café était une valeur, l’eau bouillante était une valeur et l’opérateur "plus" entre eux faisait de l’ensemble une expression qui n’était pas une valeur.

## valeurs et identité

En JavaScript, nous testons si deux valeurs sont identiques à l'opérateur `===` et si elles ne sont pas identiques à l'opérateur `!==`:

		2 === 2
			//=> true

		'hello' !== 'goodbye'
			//=> true

Comment fonctionne `===`, exactement? Imaginez que l'on vous montre une tasse de café. Et puis on vous montre une autre tasse de café. Les deux tasses sont-elles "identiques ? " En JavaScript, il y a quatre possibilités :

D'abord, parfois, les tasses sont de différentes sortes. L'un est une demitasse, l'autre une chope. Cela correspond à la comparaison de deux choses en JavaScript ayant différents *types*. Par exemple, la chaîne `"2"` n'est pas la même chose que le nombre `2`. Les chaînes et les nombres étant de types différents, les chaînes et les nombres ne sont jamais identiques:

    2 === '2'
      //=> false

    true !== 'true'
      //=> true

Deuxièmement, parfois, les tasses sont du même type--peut-être deux tasses à expresso--mais leur contenu est différent. L'un tient un simple, l'autre un double. Cela correspond à la comparaison de deux valeurs JavaScript qui ont le même type mais un "contenu" différent. Par exemple, le nombre `5` n'est pas la même chose que le nombre `2`.

    true === false
      //=> false

    2 !== 5
      //=> true

    'two' === 'five'
      //=> false

Que se passe-t-il si les tasses sont du même type *et* que le contenu est le même ? Eh bien, les troisième et quatrième possibilités de JavaScript couvrent cela.

### valeur types

Troisièmement, certains types de tasses ne portent aucune marque distinctive. S'ils sont du même genre de tasse et qu'ils ont le même contenu, nous n'avons aucun moyen de faire la différence entre eux. C'est le cas des chaînes, des nombres et des booléens que nous avons vus jusqu'à présent.

    2 + 2 === 4
      //=> true

    (2 + 2 === 4) === (2 !== 5)
      //=> true

Notez bien ce qui se passe avec ces exemples: même lorsque nous obtenons une chaîne, un nombre ou un booléen à la suite de l'évaluation d'une expression, celle-ci est identique à une autre valeur du même type avec le même "contenu". Les chaînes, les nombres et les booléens sont des exemples de ce que JavaScript appelle les types "valeur" ou "primitif". Nous utiliserons les deux termes de manière interchangeable.

Nous n'avons pas encore rencontré la quatrième possibilité. Pour étirer un peu la métaphore, certains types de tasses ont un numéro de série sur le fond. Ainsi, même si vous avez deux tasses du même type et que leur contenu est identique, vous pouvez toujours les distinguer.

![Cafe Macchiato is also a fine drink, especially when following up on the fortunes of the Azzurri or the standings in the Giro D'Italia](images/macchiato_1200.jpg)

### référence types

Alors, quels types de valeurs pourraient être du même type et avoir le même contenu, mais ne pas être considéré comme identique à JavaScript ? Rencontrons une structure de données très courante dans les langages de programmation contemporains, le *Array* (d'autres langages l'appellent parfois une liste ou un vecteur).

Un tableau ressemble à ceci: `[1, 2, 3]`. Ceci est une expression, et vous pouvez combiner `[]` avec d'autres expressions. Laissez vous aller avec des choses comme :

    [2-1, 2, 2+1]
    [1, 1+1, 1+1+1]

Notez que vous générez toujours des tableaux avec le même contenu. Mais sont-ils identiques de la même manière que chaque valeur de `42` est identique à toute autre valeur de `42` ? Essayez-les par vous-même:

    [2-1, 2, 2+1] === [1,2,3]
    [1,2,3] === [1, 2, 3]
    [1, 2, 3] === [1, 2, 3]

Que diriez-vous de ça! Lorsque vous tapez `[1, 2, 3]` ou l'une de ses variantes, vous saisissez une expression qui génère son propre tableau *unique* qui n'est identique à aucun autre tableau, même si ce dernier ressemble également à `[ 1, 2, 3]`. C'est comme si JavaScript générait de nouvelles tasses de café avec des numéros de série sur le fond.

A> Les tableaux semblent extrêmement simples, mais ce mot "référence" est tellement chargé en possibilités qu'il existe un chapitre entier consacré à la discussion [rebinding and references](#references). Essayez de saisir ce code :
A>
A> <<(code/ouroboros.js)
A>
A> Vous avez juste créé un [ouroborien](https://fr.wikipedia.org/wiki/Ouroboros) array, un array qui se contient lui même.

Ils se ressemblent, mais si vous les examinez avec `===`, vous voyez qu'ils sont différents. Chaque fois que vous évaluez une expression (y compris en tapant quelque chose) pour créer un tableau, vous créez une nouvelle valeur distincte même si elle *semble* être identique à une autre valeur de tableau. Comme nous le verrons, cela est vrai de nombreux autres types de valeurs, notamment les *fonctions*, le sujet principal de ce livre.
